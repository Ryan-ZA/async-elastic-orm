{"name":"Async-elastic-orm","tagline":"Asynchronous Java POJO to Elastic Search mapper","body":"### About\r\n\r\n**async-elastic-orm** is an asynchronous POJO-to-ElasticSearch library for Java. It allows for quick and easy saving, loading and searching of any regular java POJO with support for complex object graphs and polymorphism.\r\n\r\n### Installing\r\n\r\nYou can either add the jar to your classpath along with the ElasticSearch Java library ( http://www.elasticsearch.org/download/ ) or you can use maven and add the dependency to your pom:\r\n\r\n```\r\n\t\t<dependency>\r\n\t\t\t<groupId>io.github.ryan-za</groupId>\r\n\t\t\t<artifactId>async-elastic-orm</artifactId>\r\n\t\t\t<version>0.1</version>\r\n\t\t</dependency>\r\n```\r\n\r\n### Basic Usage\r\n\r\n#### POJO definition\r\n```\r\npublic class POJO {\r\n\t@ID String id;\r\n\tString name;\r\n}\r\n```\r\n#### Saving a POJO\r\n```\r\n\tPOJO pojo = new POJO();\r\n\tnew GDS().save(pojo).result().now();\r\n```\r\n#### Loading a POJO\r\n```\r\n\tPOJO pojo = new GDS().load().fetch(POJO.class, id).now();\r\n```\r\n#### Searching or loading multiple\r\n```\r\n\tList<POJO> list = new GDS().query(POJO.class).asList();\r\n```\r\n\r\n### Asynchronous Usage\r\n\r\n**async-elastic-orm** allows for non-blocking operations which are preferable when creating a high performance server (such as with http://vertx.io ). All operations return a *GDSResult* or *GDSMultiResult* with the operations *now()* or *later()*. Use *later()* for non-blocking. The async callbacks are optimized to be used with Java8 lambdas when they become a standard language feature by only having a single method. Error results are returned as a parameter you must check rather than a distinct callback as this seems to make for neater code.\r\n\r\n```\r\n#### Saving a POJO\r\n```\r\n\tPOJO pojo = new POJO();\r\n\tnew GDS().save(pojo).result().later(new GDSCallback<Key>() {\r\n\r\n\t\t@Override\r\n\t\tpublic void onSuccess(Key t, Throwable err) {\r\n\t\t\t// Check err for errors, the key contains the id\r\n\t\t}\r\n\t});\r\n```\r\n#### Loading a POJO\r\n```\r\n\tnew GDS().load().fetch(POJO.class, id).later(new GDSCallback<POJO>() {\r\n\t\t\t\r\n\t\t@Override\r\n\t\tpublic void onSuccess(POJO pojo, Throwable err) {\r\n\t\t\t// Check err for errors\t\r\n\t\t}\r\n\t});\r\n```\r\n#### Searching or loading multiple (full list callback)\r\n```\r\n\tList<POJO> list = new GDS().query(POJO.class).result().laterAsList(new GDSResultListReceiver<POJO>() {\r\n\t\t\t\r\n\t\t@Override\r\n\t\tpublic void success(List<POJO> list, Throwable err) {\r\n\t\t\t// Check err for errors\r\n\t\t}\r\n\t});\r\n```\r\n#### Searching or loading multiple (feeder callback)\r\n```\r\n\tList<POJO> list = new GDS().query(POJO.class).result().later(new GDSResultReceiver<POJO>() {\r\n\t\t\t\r\n\t\t@Override\r\n\t\tpublic boolean receiveNext(POJO pojo) {\r\n\t\t\treturn true; // return false to stop receiving more\r\n\t\t}\r\n\t\t\r\n\t\t@Override\r\n\t\tpublic void onError(Throwable err) {\r\n\t\t\t// Specific error callback as receiveNext() / finished() already\r\n\t\t\t// block this being used as a lambda\r\n\t\t}\r\n\t\t\t\r\n\t\t@Override\r\n\t\tpublic void finished() {\r\n\t\t\t// Called when all results have been pushed to receiveNext()\r\n\t\t}\r\n\t});\r\n```\r\n\r\n### Batching async operations\r\nThere is a *GDSBatcher* available for batching together multiple async operations so that you do not need a specific handler for each one. This is useful for only running operations when all saves or loads have completed.\r\n```\r\n\t\tTestParent testParent1 = new TestParent();\r\n\t\tGDSResult<Key> result1 = getGDS().save().entity(testParent1).result();\r\n\t\tTestParent testParent2 = new TestParent();\r\n\t\tGDSResult<Key> result2 = getGDS().save().entity(testParent2).result();\r\n\t\tTestParent testParent3 = new TestParent();\r\n\t\tGDSResult<Key> result3 = getGDS().save().entity(testParent3).result();\r\n\t\tTestParent testParent4 = new TestParent();\r\n\t\tGDSResult<Key> result4 = getGDS().save().entity(testParent4).result();\r\n\t\tTestParent testParent5 = new TestParent();\r\n\t\tGDSResult<Key> result5 = getGDS().save().entity(testParent5).result();\r\n\t\t\r\n\t\tGDSResult<Boolean> allResult = new GDSBatcher(result1, result2, result3, result4, result5).onAllComplete();\r\n\t\tboolean success = allResult.now();\r\n\t\t\r\n\t\tAssert.assertEquals(true, success);\r\n\t\t\r\n\t\tAssert.assertNotNull(testParent1.id);\r\n\t\tAssert.assertNotNull(testParent2.id);\r\n\t\tAssert.assertNotNull(testParent3.id);\r\n\t\tAssert.assertNotNull(testParent4.id);\r\n\t\tAssert.assertNotNull(testParent5.id);\r\n```\r\n\r\n### More examples\r\n\r\nMore examples of usage are available in the tests. Please help by submitting more tests.\r\n\r\n### Performance\r\n\r\nWhile this library uses reflection, all of the reflection classes are only fetched a single time and then cached for performance. With Java7+, cached reflection calls are not significantly slower than regular method calls. There are performance tests available in the tests. Performance for the Async operation mode appears to be very good and there is not much overhead compared to regular elasicsearch api commands.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}