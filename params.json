{"name":"Async-elastic-orm","tagline":"Asynchronous Java POJO to Elastic Search mapper","body":"### About\r\n\r\n**async-elastic-orm** is an asynchronous POJO-to-ElasticSearch library for Java. It allows for quick and easy saving, loading and searching of any regular java POJO with support for complex object graphs and polymorphism.\r\n\r\n### Installing\r\n\r\nYou can either add the jar to your classpath along with the ElasticSearch Java library ( http://www.elasticsearch.org/download/ ) or you can use maven and add the dependency to your pom:\r\n\r\n```\r\n<dependency>\r\n\t<groupId>io.github.ryan-za</groupId>\r\n\t<artifactId>async-elastic-orm</artifactId>\r\n\t<version>0.2.3-SNAPSHOT</version>\r\n</dependency>\r\n```\r\n\r\n### Basic Usage\r\n\r\n#### POJO definition\r\n```java\r\npublic class POJO {\r\n\t@ID String id;\r\n\tString name;\r\n}\r\n```\r\n#### Saving a POJO\r\n```java\r\nPOJO pojo = new POJO();\r\nnew GDS().save(pojo).result().now();\r\n```\r\n#### Loading a POJO\r\n```java\r\nPOJO pojo = new GDS().load().fetch(POJO.class, id).now();\r\n```\r\n#### Searching or loading multiple\r\n```java\r\nList<POJO> list = new GDS().query(POJO.class).asList();\r\n```\r\n\r\n### Asynchronous Usage\r\n\r\n**async-elastic-orm** allows for non-blocking operations which are preferable when creating a high performance server (such as with http://vertx.io ). All operations return a *GDSResult* or *GDSMultiResult* with the operations *now()* or *later()*. Use *later()* for non-blocking. The async callbacks are optimized to be used with Java8 lambdas when they become a standard language feature by only having a single method. Error results are returned as a parameter you must check rather than a distinct callback as this seems to make for neater code.\r\n\r\n#### Saving a POJO\r\n```java\r\nPOJO pojo = new POJO();\r\nnew GDS().save(pojo).result().later(new GDSCallback<Key>() {\r\n\r\n\t@Override\r\n\tpublic void onSuccess(Key t, Throwable err) {\r\n\t\t// Check err for errors, the key contains the id\r\n\t}\r\n});\r\n```\r\n#### Loading a POJO\r\n```java\r\nnew GDS().load().fetch(POJO.class, id).later(new GDSCallback<POJO>() {\r\n\t\t\t\r\n\t@Override\r\n\tpublic void onSuccess(POJO pojo, Throwable err) {\r\n\t\t// Check err for errors\t\r\n\t}\r\n});\r\n```\r\n#### Searching or loading multiple (full list callback)\r\n```java\r\nList<POJO> list = new GDS().query(POJO.class).result()\r\n\t.laterAsList(new GDSResultListReceiver<POJO>() {\r\n\t\t\t\r\n\t@Override\r\n\tpublic void success(List<POJO> list, Throwable err) {\r\n\t\t// Check err for errors\r\n\t}\r\n});\r\n```\r\n#### Searching or loading multiple (feeder callback)\r\n```java\r\nList<POJO> list = new GDS().query(POJO.class).result()\r\n\t.later(new GDSResultReceiver<POJO>() {\r\n\t\t\t\r\n\t@Override\r\n\tpublic boolean receiveNext(POJO pojo) {\r\n\t\treturn true; // return false to stop receiving more\r\n\t}\r\n\t\t\r\n\t@Override\r\n\tpublic void onError(Throwable err) {\r\n\t\t// Specific error callback as receiveNext()+finished()\r\n\t\t// block this being used as a lambda\r\n\t}\r\n\t\t\t\r\n\t@Override\r\n\tpublic void finished() {\r\n\t\t// Called when all results have been pushed to\r\n\t\t// receiveNext()\r\n\t}\r\n});\r\n```\r\n\r\n### Batching async operations\r\nThere is a *GDSBatcher* available for batching together multiple async operations so that you do not need a specific handler for each one. This is useful for only running operations when all saves or loads have completed.\r\n```java\r\nTestParent testParent1 = new TestParent();\r\nGDSResult<Key> result1 = getGDS().save().entity(testParent1).result();\r\nTestParent testParent2 = new TestParent();\r\nGDSResult<Key> result2 = getGDS().save().entity(testParent2).result();\r\nTestParent testParent3 = new TestParent();\r\nGDSResult<Key> result3 = getGDS().save().entity(testParent3).result();\r\nTestParent testParent4 = new TestParent();\r\nGDSResult<Key> result4 = getGDS().save().entity(testParent4).result();\r\nTestParent testParent5 = new TestParent();\r\nGDSResult<Key> result5 = getGDS().save().entity(testParent5).result();\r\n\t\t\r\nGDSResult<Boolean> allResult = \r\n\tnew GDSBatcher(result1, result2, result3, result4, result5)\r\n\t.onAllComplete();\r\nboolean success = allResult.now();\r\n```\r\n\r\n### Object versioning\r\n\r\nElasticsearch provides for object versioning which can be used in places where consistency is important. **async-elastic-orm** provides for easy access to this functionality by declaring a version parameter in your pojo. When doing an update of a pojo with a version field, the operation will only succeed if the version matches with the pojo being updated to ensure no data is overwritten. \r\n\r\n```java\r\npublic class TestVersionedObject {\r\n\t@ID\r\n\tString id;\r\n\t@Version\r\n\tlong ver;\r\n\t\r\n\tString name;\r\n}\r\n```\r\n```java\r\nTestVersionedObject testVersionedObject = new TestVersionedObject();\r\ntestVersionedObject.name = \"one\";\r\n\r\n// This will succeed\r\nKey key1 = getGDS().save(testVersionedObject).now();\r\n\t\t\r\ntestVersionedObject.name = \"two\";\r\n// This will also succeed as the pojo's version \r\n// has been updated on save\r\nKey key2 = getGDS().save(testVersionedObject).now();\r\n\r\n// simulate an old copy of the object\t\t\r\ntestVersionedObject.ver = 1;\r\n// This will fail as the version is older\r\ngetGDS().save(testVersionedObject).now();\r\n```\r\n\r\n### More examples\r\n\r\nMore examples of usage are available in the tests. Please help by submitting more tests.\r\n\r\n### Performance\r\n\r\nWhile this library uses reflection, all of the reflection classes are only fetched a single time and then cached for performance. With Java7+, cached reflection calls are not significantly slower than regular method calls. There are performance tests available in the tests. Performance for the Async operation mode appears to be very good and there is not much overhead compared to regular elasicsearch api commands.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}