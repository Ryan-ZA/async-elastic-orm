<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />

    <title>Async-elastic-orm by Ryan-ZA</title>
  </head>

  <body>

    <header>
      <div class="container">
        <h1>Async-elastic-orm</h1>
        <h2>Asynchronous Java POJO to Elastic Search mapper</h2>

        <section id="downloads">
          <a href="https://github.com/Ryan-ZA/async-elastic-orm/zipball/master" class="btn">Download as .zip</a>
          <a href="https://github.com/Ryan-ZA/async-elastic-orm/tarball/master" class="btn">Download as .tar.gz</a>
          <a href="https://github.com/Ryan-ZA/async-elastic-orm" class="btn btn-github"><span class="icon"></span>View on GitHub</a>
        </section>
      </div>
    </header>

    <div class="container">
      <section id="main_content">
        <h3>
<a name="about" class="anchor" href="#about"><span class="octicon octicon-link"></span></a>About</h3>

<p><strong>async-elastic-orm</strong> is an asynchronous POJO-to-ElasticSearch library for Java. It allows for quick and easy saving, loading and searching of any regular java POJO with support for complex object graphs and polymorphism.</p>

<h3>
<a name="installing" class="anchor" href="#installing"><span class="octicon octicon-link"></span></a>Installing</h3>

<p>You can either add the jar to your classpath along with the ElasticSearch Java library ( <a href="http://www.elasticsearch.org/download/">http://www.elasticsearch.org/download/</a> ) or you can use maven and add the dependency to your pom:</p>

<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;io.github.ryan-za&lt;/groupId&gt;
    &lt;artifactId&gt;async-elastic-orm&lt;/artifactId&gt;
    &lt;version&gt;0.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<h3>
<a name="basic-usage" class="anchor" href="#basic-usage"><span class="octicon octicon-link"></span></a>Basic Usage</h3>

<h4>
<a name="pojo-definition" class="anchor" href="#pojo-definition"><span class="octicon octicon-link"></span></a>POJO definition</h4>

<pre><code>public class POJO {
    @ID String id;
    String name;
}
</code></pre>

<h4>
<a name="saving-a-pojo" class="anchor" href="#saving-a-pojo"><span class="octicon octicon-link"></span></a>Saving a POJO</h4>

<pre><code>POJO pojo = new POJO();
new GDS().save(pojo).result().now();
</code></pre>

<h4>
<a name="loading-a-pojo" class="anchor" href="#loading-a-pojo"><span class="octicon octicon-link"></span></a>Loading a POJO</h4>

<pre><code>POJO pojo = new GDS().load().fetch(POJO.class, id).now();
</code></pre>

<h4>
<a name="searching-or-loading-multiple" class="anchor" href="#searching-or-loading-multiple"><span class="octicon octicon-link"></span></a>Searching or loading multiple</h4>

<pre><code>List&lt;POJO&gt; list = new GDS().query(POJO.class).asList();
</code></pre>

<h3>
<a name="asynchronous-usage" class="anchor" href="#asynchronous-usage"><span class="octicon octicon-link"></span></a>Asynchronous Usage</h3>

<p><strong>async-elastic-orm</strong> allows for non-blocking operations which are preferable when creating a high performance server (such as with <a href="http://vertx.io">http://vertx.io</a> ). All operations return a <em>GDSResult</em> or <em>GDSMultiResult</em> with the operations <em>now()</em> or <em>later()</em>. Use <em>later()</em> for non-blocking. The async callbacks are optimized to be used with Java8 lambdas when they become a standard language feature by only having a single method. Error results are returned as a parameter you must check rather than a distinct callback as this seems to make for neater code.</p>

<h4>
<a name="saving-a-pojo-1" class="anchor" href="#saving-a-pojo-1"><span class="octicon octicon-link"></span></a>Saving a POJO</h4>

<pre><code>POJO pojo = new POJO();
new GDS().save(pojo).result().later(new GDSCallback&lt;Key&gt;() {

    @Override
    public void onSuccess(Key t, Throwable err) {
        // Check err for errors, the key contains the id
    }
});
</code></pre>

<h4>
<a name="loading-a-pojo-1" class="anchor" href="#loading-a-pojo-1"><span class="octicon octicon-link"></span></a>Loading a POJO</h4>

<pre><code>new GDS().load().fetch(POJO.class, id).later(new GDSCallback&lt;POJO&gt;() {

    @Override
    public void onSuccess(POJO pojo, Throwable err) {
        // Check err for errors 
    }
});
</code></pre>

<h4>
<a name="searching-or-loading-multiple-full-list-callback" class="anchor" href="#searching-or-loading-multiple-full-list-callback"><span class="octicon octicon-link"></span></a>Searching or loading multiple (full list callback)</h4>

<pre><code>List&lt;POJO&gt; list = new GDS().query(POJO.class).result()
    .laterAsList(new GDSResultListReceiver&lt;POJO&gt;() {

    @Override
    public void success(List&lt;POJO&gt; list, Throwable err) {
        // Check err for errors
    }
});
</code></pre>

<h4>
<a name="searching-or-loading-multiple-feeder-callback" class="anchor" href="#searching-or-loading-multiple-feeder-callback"><span class="octicon octicon-link"></span></a>Searching or loading multiple (feeder callback)</h4>

<pre><code>List&lt;POJO&gt; list = new GDS().query(POJO.class).result()
    .later(new GDSResultReceiver&lt;POJO&gt;() {

    @Override
    public boolean receiveNext(POJO pojo) {
        return true; // return false to stop receiving more
    }

    @Override
    public void onError(Throwable err) {
        // Specific error callback as receiveNext() / finished() already
        // block this being used as a lambda
    }

    @Override
    public void finished() {
        // Called when all results have been pushed to receiveNext()
    }
});
</code></pre>

<h3>
<a name="batching-async-operations" class="anchor" href="#batching-async-operations"><span class="octicon octicon-link"></span></a>Batching async operations</h3>

<p>There is a <em>GDSBatcher</em> available for batching together multiple async operations so that you do not need a specific handler for each one. This is useful for only running operations when all saves or loads have completed.</p>

<pre><code>TestParent testParent1 = new TestParent();
GDSResult&lt;Key&gt; result1 = getGDS().save().entity(testParent1).result();
TestParent testParent2 = new TestParent();
GDSResult&lt;Key&gt; result2 = getGDS().save().entity(testParent2).result();
TestParent testParent3 = new TestParent();
GDSResult&lt;Key&gt; result3 = getGDS().save().entity(testParent3).result();
TestParent testParent4 = new TestParent();
GDSResult&lt;Key&gt; result4 = getGDS().save().entity(testParent4).result();
TestParent testParent5 = new TestParent();
GDSResult&lt;Key&gt; result5 = getGDS().save().entity(testParent5).result();

GDSResult&lt;Boolean&gt; allResult = 
    new GDSBatcher(result1, result2, result3, result4, result5)
    .onAllComplete();
boolean success = allResult.now();
</code></pre>

<h3>
<a name="more-examples" class="anchor" href="#more-examples"><span class="octicon octicon-link"></span></a>More examples</h3>

<p>More examples of usage are available in the tests. Please help by submitting more tests.</p>

<h3>
<a name="performance" class="anchor" href="#performance"><span class="octicon octicon-link"></span></a>Performance</h3>

<p>While this library uses reflection, all of the reflection classes are only fetched a single time and then cached for performance. With Java7+, cached reflection calls are not significantly slower than regular method calls. There are performance tests available in the tests. Performance for the Async operation mode appears to be very good and there is not much overhead compared to regular elasicsearch api commands.</p>
      </section>
    </div>

    
  </body>
</html>